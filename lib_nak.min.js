module.exports = function (vfs, register) { 
	register(null, { 
	execute: function (passedArgs, callback) { 
var isbinaryfile, lrucache;
var fs = require('fs');

isbinaryfile = function(bytes, size) {
    // Read the file with no encoding for raw buffer access.
    if (size === undefined) {
        var file = bytes;
        if (!fs.existsSync(file))
           return false;
        bytes = fs.readFileSync(file);
        size = fs.statSync(file).size;
    } 

    if (size === 0) 
        return false;

    var suspicious_bytes = 0;
    var total_bytes = size > 512 ? 512 : size;
    
    if (size >= 3 && bytes[0] == 0xEF && bytes[1] == 0xBB && bytes[2] == 0xBF) {
        // UTF-8 BOM. This isn't binary.
        return false;
    }

    for (var i = 0; i < total_bytes; i++) {  
        if (bytes[i] === 0) { // NULL byte--it's binary!
            return true;
        }
        else if ((bytes[i] < 7 || bytes[i] > 14) && (bytes[i] < 32 || bytes[i] > 127)) {
            // UTF-8 detection
            if (bytes[i] > 191 && bytes[i] < 224 && i + 1 < total_bytes) {
                i++;
                if (bytes[i] < 192) {
                    continue;
                }
            } 
            else if (bytes[i] > 223 && bytes[i] < 239 && i + 2 < total_bytes) {
                i++;
                if (bytes[i] < 192 && bytes[i + 1] < 192) {
                    i++;
                    continue;
                }
            }
            suspicious_bytes++;
            // Read at least 32 bytes before making a decision
            if (i > 32 && (suspicious_bytes * 100) / total_bytes > 10) {
                return true;
            } 
        }
    }

    if ((suspicious_bytes * 100) / total_bytes > 10) {
        return true;
    }
    
    return false;
}
module.exports = sigmund
function sigmund (subject, maxSessions) {
    maxSessions = maxSessions || 10;
    var notes = [];
    var analysis = '';
    var RE = RegExp;

    function psychoAnalyze (subject, session) {
        if (session > maxSessions) return;

        if (typeof subject === 'function' ||
            typeof subject === 'undefined') {
            return;
        }

        if (typeof subject !== 'object' || !subject ||
            (subject instanceof RE)) {
            analysis += subject;
            return;
        }

        if (notes.indexOf(subject) !== -1 || session === maxSessions) return;

        notes.push(subject);
        analysis += '{';
        Object.keys(subject).forEach(function (issue, _, __) {
            // pseudo-private values.  skip those.
            if (issue.charAt(0) === '_') return;
            var to = typeof subject[issue];
            if (to === 'function' || to === 'undefined') return;
            analysis += issue;
            psychoAnalyze(subject[issue], session + 1);
        });
    }
    psychoAnalyze(subject, 0);
    return analysis;
}

// vim: set softtabstop=4 shiftwidth=4:

;(function () { // closure for web browsers

if (typeof module === 'object' && module.exports) {
  lrucache = LRUCache
} else {
  // just set the global for non-node platforms.
  this.LRUCache = LRUCache
}

function hOP (obj, key) {
  return Object.prototype.hasOwnProperty.call(obj, key)
}

function naiveLength () { return 1 }

function LRUCache (options) {
  if (!(this instanceof LRUCache)) {
    return new LRUCache(options)
  }

  var max
  if (typeof options === 'number') {
    max = options
    options = { max: max }
  }

  if (!options) options = {}

  max = options.max

  var lengthCalculator = options.length || naiveLength

  if (typeof lengthCalculator !== "function") {
    lengthCalculator = naiveLength
  }

  if (!max || !(typeof max === "number") || max <= 0 ) {
    // a little bit silly.  maybe this should throw?
    max = Infinity
  }

  var allowStale = options.stale || false

  var maxAge = options.maxAge || null

  var dispose = options.dispose

  var cache = Object.create(null) // hash of items by key
    , lruList = Object.create(null) // list of items in order of use recency
    , mru = 0 // most recently used
    , length = 0 // number of items in the list
    , itemCount = 0


  // resize the cache when the max changes.
  Object.defineProperty(this, "max",
    { set : function (mL) {
        if (!mL || !(typeof mL === "number") || mL <= 0 ) mL = Infinity
        max = mL
        // if it gets above double max, trim right away.
        // otherwise, do it whenever it's convenient.
        if (length > max) trim()
      }
    , get : function () { return max }
    , enumerable : true
    })

  // resize the cache when the lengthCalculator changes.
  Object.defineProperty(this, "lengthCalculator",
    { set : function (lC) {
        if (typeof lC !== "function") {
          lengthCalculator = naiveLength
          length = itemCount
          for (var key in cache) {
            cache[key].length = 1
          }
        } else {
          lengthCalculator = lC
          length = 0
          for (var key in cache) {
            cache[key].length = lengthCalculator(cache[key].value)
            length += cache[key].length
          }
        }

        if (length > max) trim()
      }
    , get : function () { return lengthCalculator }
    , enumerable : true
    })

  Object.defineProperty(this, "length",
    { get : function () { return length }
    , enumerable : true
    })


  Object.defineProperty(this, "itemCount",
    { get : function () { return itemCount }
    , enumerable : true
    })

  this.forEach = function (fn, thisp) {
    thisp = thisp || this
    var i = 0;
    for (var k = mru - 1; k >= 0 && i < itemCount; k--) if (lruList[k]) {
      i++
      var hit = lruList[k]
      fn.call(thisp, hit.value, hit.key, this)
    }
  }

  this.keys = function () {
    var keys = new Array(itemCount)
    var i = 0
    for (var k = mru - 1; k >= 0 && i < itemCount; k--) if (lruList[k]) {
      var hit = lruList[k]
      keys[i++] = hit.key
    }
    return keys
  }

  this.values = function () {
    var values = new Array(itemCount)
    var i = 0
    for (var k = mru - 1; k >= 0 && i < itemCount; k--) if (lruList[k]) {
      var hit = lruList[k]
      values[i++] = hit.value
    }
    return values
  }

  this.reset = function () {
    if (dispose) {
      for (var k in cache) {
        dispose(k, cache[k].value)
      }
    }
    cache = {}
    lruList = {}
    mru = 0
    length = 0
    itemCount = 0
  }

  // Provided for debugging/dev purposes only. No promises whatsoever that
  // this API stays stable.
  this.dump = function () {
    return cache
  }

  this.dumpLru = function () {
    return lruList
  }

  this.set = function (key, value) {
    if (hOP(cache, key)) {
      // dispose of the old one before overwriting
      if (dispose) dispose(key, cache[key].value)
      if (maxAge) cache[key].now = Date.now()
      cache[key].value = value
      this.get(key)
      return true
    }

    var len = lengthCalculator(value)
    var age = maxAge ? Date.now() : 0
    var hit = new Entry(key, value, mru++, len, age)

    // oversized objects fall out of cache automatically.
    if (hit.length > max) {
      if (dispose) dispose(key, value)
      return false
    }

    length += hit.length
    lruList[hit.lu] = cache[key] = hit
    itemCount ++

    if (length > max) trim()
    return true
  }

  this.has = function (key) {
    if (!hOP(cache, key)) return false
    var hit = cache[key]
    if (maxAge && (Date.now() - hit.now > maxAge)) {
      return false
    }
    return true
  }

  this.get = function (key) {
    if (!hOP(cache, key)) return
    var hit = cache[key]
    if (maxAge && (Date.now() - hit.now > maxAge)) {
      this.del(key)
      return allowStale ? hit.value : undefined
    }
    delete lruList[hit.lu]
    hit.lu = mru ++
    lruList[hit.lu] = hit
    return hit.value
  }

  this.del = function (key) {
    if (!hOP(cache, key)) return
    var hit = cache[key]
    if (dispose) dispose(key, hit.value)
    delete cache[key]
    delete lruList[hit.lu]
    length -= hit.length
    itemCount --
  }

  function trim () {
    if (length <= max) return
    for (var k in lruList) {
      if (length <= max) break;
      var hit = lruList[k]
      if (dispose) dispose(hit.key, hit.value)
      length -= hit.length
      itemCount --
      delete cache[ hit.key ]
      delete lruList[k]
    }
  }
}

// classy, since V8 prefers predictable objects.
function Entry (key, value, mru, len, age) {
  this.key = key
  this.value = value
  this.lu = mru
  this.length = len
  this.now = age
}

})()

module.exports = minimatch

minimatch.Minimatch = Minimatch

var LRU = lrucache
  , cache = minimatch.cache = new LRU({max: 100})
  , GLOBSTAR = minimatch.GLOBSTAR = Minimatch.GLOBSTAR = {}
  , sigmund = sigmund

var path = require("path")
  // any single thing other than /
  // don't need to escape / when using new RegExp()
  , qmark = "[^/]"

  // * => any number of characters
  , star = qmark + "*?"

  // ** when dots are allowed.  Anything goes, except .. and .
  // not (^ or / followed by one or two dots followed by $ or /),
  // followed by anything, any number of times.
  , twoStarDot = "(?:(?!(?:\\\/|^)(?:\\.{1,2})($|\\\/)).)*?"

  // not a ^ or / followed by a dot,
  // followed by anything, any number of times.
  , twoStarNoDot = "(?:(?!(?:\\\/|^)\\.).)*?"

  // characters that need to be escaped in RegExp.
  , reSpecials = charSet("().*{}+?[]^$\\!")

// "abc" -> { a:true, b:true, c:true }
function charSet (s) {
  return s.split("").reduce(function (set, c) {
    set[c] = true
    return set
  }, {})
}

function ext (a, b) {
  a = a || {}
  b = b || {}
  var t = {}
  Object.keys(b).forEach(function (k) {
    t[k] = b[k]
  })
  Object.keys(a).forEach(function (k) {
    t[k] = a[k]
  })
  return t
}

minimatch.defaults = function (def) {
  if (!def || !Object.keys(def).length) return minimatch

  var orig = minimatch

  var m = function minimatch (p, pattern, options) {
    return orig.minimatch(p, pattern, ext(def, options))
  }

  m.Minimatch = function Minimatch (pattern, options) {
    return new orig.Minimatch(pattern, ext(def, options))
  }

  return m
}

Minimatch.defaults = function (def) {
  if (!def || !Object.keys(def).length) return Minimatch
  return minimatch.defaults(def).Minimatch
}


function minimatch (p, pattern, options) {
  if (typeof pattern !== "string") {
    throw new TypeError("glob pattern string required")
  }

  if (!options) options = {}

  // shortcut: comments match nothing.
  if (!options.nocomment && pattern.charAt(0) === "#") {
    return false
  }

  // "" only matches ""
  if (pattern.trim() === "") return p === ""

  return new Minimatch(pattern, options).match(p)
}

function Minimatch (pattern, options) {
  if (!(this instanceof Minimatch)) {
    return new Minimatch(pattern, options, cache)
  }

  if (typeof pattern !== "string") {
    throw new TypeError("glob pattern string required")
  }

  if (!options) options = {}
  pattern = pattern.trim()

  // windows: need to use /, not \
  // On other platforms, \ is a valid (albeit bad) filename char.
  if (process.platform === "win32") {
    pattern = pattern.split("\\").join("/")
  }

  // lru storage.
  // these things aren't particularly big, but walking down the string
  // and turning it into a regexp can get pretty costly.
  var cacheKey = pattern + "\n" + sigmund(options)
  var cached = minimatch.cache.get(cacheKey)
  if (cached) return cached
  minimatch.cache.set(cacheKey, this)

  this.options = options
  this.set = []
  this.pattern = pattern
  this.regexp = null
  this.negate = false
  this.comment = false
  this.empty = false

  // make the set of regexps etc.
  this.make()
}

Minimatch.prototype.make = make
function make () {
  // don't do it more than once.
  if (this._made) return

  var pattern = this.pattern
  var options = this.options

  // empty patterns and comments match nothing.
  if (!options.nocomment && pattern.charAt(0) === "#") {
    this.comment = true
    return
  }
  if (!pattern) {
    this.empty = true
    return
  }

  // step 1: figure out negation, etc.
  this.parseNegate()

  // step 2: expand braces
  var set = this.globSet = this.braceExpand()

  if (options.debug) console.error(this.pattern, set)

  // step 3: now we have a set, so turn each one into a series of path-portion
  // matching patterns.
  // These will be regexps, except in the case of "**", which is
  // set to the GLOBSTAR object for globstar behavior,
  // and will not contain any / characters
  set = this.globParts = set.map(function (s) {
    return s.split(path.dir_sep)
  })

  if (options.debug) console.error(this.pattern, set)

  // glob --> regexps
  set = set.map(function (s, si, set) {
    return s.map(this.parse, this)
  }, this)

  if (options.debug) console.error(this.pattern, set)

  // filter out everything that didn't compile properly.
  set = set.filter(function (s) {
    return -1 === s.indexOf(false)
  })

  if (options.debug) console.error(this.pattern, set)

  this.set = set
}

Minimatch.prototype.parseNegate = parseNegate
function parseNegate () {
  var pattern = this.pattern
    , negate = false
    , options = this.options
    , negateOffset = 0

  if (options.nonegate) return

  for ( var i = 0, l = pattern.length
      ; i < l && pattern.charAt(i) === "!"
      ; i ++) {
    negate = !negate
    negateOffset ++
  }

  if (negateOffset) this.pattern = pattern.substr(negateOffset)
  this.negate = negate
}

// Brace expansion:
// a{b,c}d -> abd acd
// a{b,}c -> abc ac
// a{0..3}d -> a0d a1d a2d a3d
// a{b,c{d,e}f}g -> abg acdfg acefg
// a{b,c}d{e,f}g -> abdeg acdeg abdeg abdfg
//
// Invalid sets are not expanded.
// a{2..}b -> a{2..}b
// a{b}c -> a{b}c
minimatch.braceExpand = function (pattern, options) {
  return new Minimatch(pattern, options).braceExpand()
}

Minimatch.prototype.braceExpand = braceExpand
function braceExpand (pattern, options) {
  options = options || this.options
  pattern = typeof pattern === "undefined"
    ? this.pattern : pattern

  if (typeof pattern === "undefined") {
    throw new Error("undefined pattern")
  }

  if (options.nobrace ||
      !pattern.match(/\{.*\}/)) {
    // shortcut. no need to expand.
    return [pattern]
  }

  var escaping = false

  // examples and comments refer to this crazy pattern:
  // a{b,c{d,e},{f,g}h}x{y,z}
  // expected:
  // abxy
  // abxz
  // acdxy
  // acdxz
  // acexy
  // acexz
  // afhxy
  // afhxz
  // aghxy
  // aghxz

  // everything before the first \{ is just a prefix.
  // So, we pluck that off, and work with the rest,
  // and then prepend it to everything we find.
  if (pattern.charAt(0) !== "{") {
    // console.error(pattern)
    var prefix = null
    for (var i = 0, l = pattern.length; i < l; i ++) {
      var c = pattern.charAt(i)
      // console.error(i, c)
      if (c === "\\") {
        escaping = !escaping
      } else if (c === "{" && !escaping) {
        prefix = pattern.substr(0, i)
        break
      }
    }

    // actually no sets, all { were escaped.
    if (prefix === null) {
      // console.error("no sets")
      return [pattern]
    }

    var tail = braceExpand(pattern.substr(i), options)
    return tail.map(function (t) {
      return prefix + t
    })
  }

  // now we have something like:
  // {b,c{d,e},{f,g}h}x{y,z}
  // walk through the set, expanding each part, until
  // the set ends.  then, we'll expand the suffix.
  // If the set only has a single member, then'll put the {} back

  // first, handle numeric sets, since they're easier
  var numset = pattern.match(/^\{(-?[0-9]+)\.\.(-?[0-9]+)\}/)
  if (numset) {
    // console.error("numset", numset[1], numset[2])
    var suf = braceExpand(pattern.substr(numset[0].length), options)
      , start = +numset[1]
      , end = +numset[2]
      , inc = start > end ? -1 : 1
      , set = []
    for (var i = start; i != (end + inc); i += inc) {
      // append all the suffixes
      for (var ii = 0, ll = suf.length; ii < ll; ii ++) {
        set.push(i + suf[ii])
      }
    }
    return set
  }

  // ok, walk through the set
  // We hope, somewhat optimistically, that there
  // will be a } at the end.
  // If the closing brace isn't found, then the pattern is
  // interpreted as braceExpand("\\" + pattern) so that
  // the leading \{ will be interpreted literally.
  var i = 1 // skip the \{
    , depth = 1
    , set = []
    , member = ""
    , sawEnd = false
    , escaping = false

  function addMember () {
    set.push(member)
    member = ""
  }

  // console.error("Entering for")
  FOR: for (i = 1, l = pattern.length; i < l; i ++) {
    var c = pattern.charAt(i)
    // console.error("", i, c)

    if (escaping) {
      escaping = false
      member += "\\" + c
    } else {
      switch (c) {
        case "\\":
          escaping = true
          continue

        case "{":
          depth ++
          member += "{"
          continue

        case "}":
          depth --
          // if this closes the actual set, then we're done
          if (depth === 0) {
            addMember()
            // pluck off the close-brace
            i ++
            break FOR
          } else {
            member += c
            continue
          }

        case ",":
          if (depth === 1) {
            addMember()
          } else {
            member += c
          }
          continue

        default:
          member += c
          continue
      } // switch
    } // else
  } // for

  // now we've either finished the set, and the suffix is
  // pattern.substr(i), or we have *not* closed the set,
  // and need to escape the leading brace
  if (depth !== 0) {
    // console.error("didn't close", pattern)
    return braceExpand("\\" + pattern, options)
  }

  // x{y,z} -> ["xy", "xz"]
  // console.error("set", set)
  // console.error("suffix", pattern.substr(i))
  var suf = braceExpand(pattern.substr(i), options)
  // ["b", "c{d,e}","{f,g}h"] ->
  //   [["b"], ["cd", "ce"], ["fh", "gh"]]
  var addBraces = set.length === 1
  // console.error("set pre-expanded", set)
  set = set.map(function (p) {
    return braceExpand(p, options)
  })
  // console.error("set expanded", set)


  // [["b"], ["cd", "ce"], ["fh", "gh"]] ->
  //   ["b", "cd", "ce", "fh", "gh"]
  set = set.reduce(function (l, r) {
    return l.concat(r)
  })

  if (addBraces) {
    set = set.map(function (s) {
      return "{" + s + "}"
    })
  }

  // now attach the suffixes.
  var ret = []
  for (var i = 0, l = set.length; i < l; i ++) {
    for (var ii = 0, ll = suf.length; ii < ll; ii ++) {
      ret.push(set[i] + suf[ii])
    }
  }
  return ret
}

// parse a component of the expanded set.
// At this point, no pattern may contain "/" in it
// so we're going to return a 2d array, where each entry is the full
// pattern, split on '/', and then turned into a regular expression.
// A regexp is made at the end which joins each array with an
// escaped /, and another full one which joins each regexp with |.
//
// Following the lead of Bash 4.1, note that "**" only has special meaning
// when it is the *only* thing in a path portion.  Otherwise, any series
// of * is equivalent to a single *.  Globstar behavior is enabled by
// default, and can be disabled by setting options.noglobstar.
Minimatch.prototype.parse = parse
var SUBPARSE = {}
function parse (pattern, isSub) {
  var options = this.options

  // shortcuts
  if (!options.noglobstar && pattern === "**") return GLOBSTAR
  if (pattern === "") return ""

  var re = ""
    , hasMagic = !!options.nocase
    , escaping = false
    // ? => one single character
    , patternListStack = []
    , plType
    , stateChar
    , inClass = false
    , reClassStart = -1
    , classStart = -1
    // . and .. never match anything that doesn't start with .,
    // even when options.dot is set.
    , patternStart = pattern.charAt(0) === "." ? "" // anything
      // not (start or / followed by . or .. followed by / or end)
      : options.dot ? "(?!(?:^|\\\/)\\.{1,2}(?:$|\\\/))"
      : "(?!\\.)"

  function clearStateChar () {
    if (stateChar) {
      // we had some state-tracking character
      // that wasn't consumed by this pass.
      switch (stateChar) {
        case "*":
          re += star
          hasMagic = true
          break
        case "?":
          re += qmark
          hasMagic = true
          break
        default:
          re += "\\"+stateChar
          break
      }
      stateChar = false
    }
  }

  for ( var i = 0, len = pattern.length, c
      ; (i < len) && (c = pattern.charAt(i))
      ; i ++ ) {

    if (options.debug) {
      console.error("%s\t%s %s %j", pattern, i, re, c)
    }

    // skip over any that are escaped.
    if (escaping && reSpecials[c]) {
      re += "\\" + c
      escaping = false
      continue
    }

    SWITCH: switch (c) {
      case "/":
        // completely not allowed, even escaped.
        // Should already be path-split by now.
        return false

      case "\\":
        clearStateChar()
        escaping = true
        continue

      // the various stateChar values
      // for the "extglob" stuff.
      case "?":
      case "*":
      case "+":
      case "@":
      case "!":
        if (options.debug) {
          console.error("%s\t%s %s %j <-- stateChar", pattern, i, re, c)
        }

        // all of those are literals inside a class, except that
        // the glob [!a] means [^a] in regexp
        if (inClass) {
          if (c === "!" && i === classStart + 1) c = "^"
          re += c
          continue
        }

        // if we already have a stateChar, then it means
        // that there was something like ** or +? in there.
        // Handle the stateChar, then proceed with this one.
        clearStateChar()
        stateChar = c
        // if extglob is disabled, then +(asdf|foo) isn't a thing.
        // just clear the statechar *now*, rather than even diving into
        // the patternList stuff.
        if (options.noext) clearStateChar()
        continue

      case "(":
        if (inClass) {
          re += "("
          continue
        }

        if (!stateChar) {
          re += "\\("
          continue
        }

        plType = stateChar
        patternListStack.push({ type: plType
                              , start: i - 1
                              , reStart: re.length })
        // negation is (?:(?!js)[^/]*)
        re += stateChar === "!" ? "(?:(?!" : "(?:"
        stateChar = false
        continue

      case ")":
        if (inClass || !patternListStack.length) {
          re += "\\)"
          continue
        }

        hasMagic = true
        re += ")"
        plType = patternListStack.pop().type
        // negation is (?:(?!js)[^/]*)
        // The others are (?:<pattern>)<type>
        switch (plType) {
          case "!":
            re += "[^/]*?)"
            break
          case "?":
          case "+":
          case "*": re += plType
          case "@": break // the default anyway
        }
        continue

      case "|":
        if (inClass || !patternListStack.length || escaping) {
          re += "\\|"
          escaping = false
          continue
        }

        re += "|"
        continue

      // these are mostly the same in regexp and glob
      case "[":
        // swallow any state-tracking char before the [
        clearStateChar()

        if (inClass) {
          re += "\\" + c
          continue
        }

        inClass = true
        classStart = i
        reClassStart = re.length
        re += c
        continue

      case "]":
        //  a right bracket shall lose its special
        //  meaning and represent itself in
        //  a bracket expression if it occurs
        //  first in the list.  -- POSIX.2 2.8.3.2
        if (i === classStart + 1 || !inClass) {
          re += "\\" + c
          escaping = false
          continue
        }

        // finish up the class.
        hasMagic = true
        inClass = false
        re += c
        continue

      default:
        // swallow any state char that wasn't consumed
        clearStateChar()

        if (escaping) {
          // no need
          escaping = false
        } else if (reSpecials[c]
                   && !(c === "^" && inClass)) {
          re += "\\"
        }

        re += c

    } // switch
  } // for


  // handle the case where we left a class open.
  // "[abc" is valid, equivalent to "\[abc"
  if (inClass) {
    // split where the last [ was, and escape it
    // this is a huge pita.  We now have to re-walk
    // the contents of the would-be class to re-translate
    // any characters that were passed through as-is
    var cs = pattern.substr(classStart + 1)
      , sp = this.parse(cs, SUBPARSE)
    re = re.substr(0, reClassStart) + "\\[" + sp[0]
    hasMagic = hasMagic || sp[1]
  }

  // handle the case where we had a +( thing at the *end*
  // of the pattern.
  // each pattern list stack adds 3 chars, and we need to go through
  // and escape any | chars that were passed through as-is for the regexp.
  // Go through and escape them, taking care not to double-escape any
  // | chars that were already escaped.
  var pl
  while (pl = patternListStack.pop()) {
    var tail = re.slice(pl.reStart + 3)
    // maybe some even number of \, then maybe 1 \, followed by a |
    tail = tail.replace(/((?:\\{2})*)(\\?)\|/g, function (_, $1, $2) {
      if (!$2) {
        // the | isn't already escaped, so escape it.
        $2 = "\\"
      }

      // need to escape all those slashes *again*, without escaping the
      // one that we need for escaping the | character.  As it works out,
      // escaping an even number of slashes can be done by simply repeating
      // it exactly after itself.  That's why this trick works.
      //
      // I am sorry that you have to see this.
      return $1 + $1 + $2 + "|"
    })

    // console.error("tail=%j\n   %s", tail, tail)
    var t = pl.type === "*" ? star
          : pl.type === "?" ? qmark
          : "\\" + pl.type

    hasMagic = true
    re = re.slice(0, pl.reStart)
       + t + "\\("
       + tail
  }

  // handle trailing things that only matter at the very end.
  clearStateChar()
  if (escaping) {
    // trailing \\
    re += "\\\\"
  }

  // only need to apply the nodot start if the re starts with
  // something that could conceivably capture a dot
  var addPatternStart = false
  switch (re.charAt(0)) {
    case ".":
    case "[":
    case "(": addPatternStart = true
  }

  // if the re is not "" at this point, then we need to make sure
  // it doesn't match against an empty path part.
  // Otherwise a/* will match a/, which it should not.
  if (re !== "" && hasMagic) re = "(?=.)" + re

  if (addPatternStart) re = patternStart + re

  // parsing just a piece of a larger pattern.
  if (isSub === SUBPARSE) {
    return [ re, hasMagic ]
  }

  // skip the regexp for non-magical patterns
  // unescape anything in it, though, so that it'll be
  // an exact match against a file etc.
  if (!hasMagic) {
    return globUnescape(pattern)
  }

  var flags = options.nocase ? "i" : ""
    , regExp = new RegExp("^" + re + "$", flags)

  regExp._glob = pattern
  regExp._src = re

  return regExp
}

minimatch.makeRe = function (pattern, options) {
  return new Minimatch(pattern, options || {}).makeRe()
}

Minimatch.prototype.makeRe = makeRe
function makeRe () {
  if (this.regexp || this.regexp === false) return this.regexp

  // at this point, this.set is a 2d array of partial
  // pattern strings, or "**".
  //
  // It's better to use .match().  This function shouldn't
  // be used, really, but it's pretty convenient sometimes,
  // when you just want to work with a regex.
  var set = this.set

  if (!set.length) return this.regexp = false
  var options = this.options

  var twoStar = options.noglobstar ? star
      : options.dot ? twoStarDot
      : twoStarNoDot
    , flags = options.nocase ? "i" : ""

  var re = set.map(function (pattern) {
    return pattern.map(function (p) {
      return (p === GLOBSTAR) ? twoStar
           : (typeof p === "string") ? regExpEscape(p)
           : p._src
    }).join("\\\/")
  }).join("|")

  // must match entire pattern
  // ending in a * or ** will make it less strict.
  re = "^" + re + "$"

  // can match anything, as long as it's not this.
  if (this.negate) re = "^(?!" + re + ").*$"

  try {
    return this.regexp = new RegExp(re, flags)
  } catch (ex) {
    return this.regexp = false
  }
}

minimatch.match = function (list, pattern, options) {
  var mm = new Minimatch(pattern, options)
  list = list.filter(function (f) {
    return mm.match(f)
  })
  if (options.nonull && !list.length) {
    list.push(pattern)
  }
  return list
}

Minimatch.prototype.match = match
function match (name, path, splitPath, partial) {
  // console.error("match", f, this.pattern)
  // short-circuit in the case of busted things.
  // comments, etc.
  // if (this.comment) return false
  // if (this.empty) return f === ""

  // if (f === "/" && partial) return true

  var options = this.options

  // windows: need to use /, not \
  // On other platforms, \ is a valid (albeit bad) filename char.
  // if (platform === "win32") {
  //   f = f.split("\\").join("/")
  // }

  // treat the test path as a set of pathparts.
  // f = f.split(slashSplit)
  // if (options.debug) {
  //   console.error(this.pattern, "split", f)
  // }

  // just ONE of the pattern sets in this.set needs to match
  // in order for it to be valid.  If negating, then just one
  // match means that we have failed.
  // Either way, return on the first hit.

  var set = this.set
  // console.error(this.pattern, "set", set)

  for (var i = 0, l = set.length; i < l; i ++) {
    var pattern = set[i];
    var hit = this.matchOne(name, path, splitPath, pattern, partial)
    if (hit) {
      if (options.flipNegate) return true
      return !this.negate
    }
  }

  // didn't get any hits.  this is success if it's a negative
  // pattern, failure otherwise.
  if (options.flipNegate) return false
  return this.negate
}

// set partial to true to test if, for example,
// "/a/b" matches the start of "/*/b/*/d"
// Partial means, if you run out of file before you run
// out of pattern, then that's fine, as long as all
// the parts match.
Minimatch.prototype.matchOne = function(name, filepath, splitPath, pattern, partial) { // file is splitted function (file, pattern, partial) {
  var options = this.options

  // if (options.debug) {
  //   console.error("matchOne",
  //                 { "this": this
  //                 , file: file
  //                 , pattern: pattern })
  // }

  if (options.matchBase && pattern.length === 1) {
    //file = path.basename(file.join("/")).split("/")
    splitPath = [name];
  }

  // if (options.debug) {
  //   console.error("matchOne", file.length, pattern.length)
  // }

  for ( var fi = 0
          , pi = 0
          , fl = splitPath.length
          , pl = pattern.length
      ; (fi < fl) && (pi < pl)
      ; fi ++, pi ++ ) {

    if (options.debug) {
      console.error("matchOne loop")
    }
    var p = pattern[pi]
      , f = splitPath[fi]

    if (options.debug) {
      console.error(pattern, p, f)
    }

    // should be impossible.
    // some invalid regexp stuff in the set.
    if (p === false) return false

    if (p === GLOBSTAR) {
      if (options.debug)
        console.error('GLOBSTAR', [pattern, p, f])

      // "**"
      // a/**/b/**/c would match the following:
      // a/b/x/y/z/c
      // a/x/y/z/b/c
      // a/b/x/b/x/c
      // a/b/c
      // To do this, take the rest of the pattern after
      // the **, and see if it would match the file remainder.
      // If so, return success.
      // If not, the ** "swallows" a segment, and try again.
      // This is recursively awful.
      //
      // a/**/b/**/c matching a/b/x/y/z/c
      // - a matches a
      // - doublestar
      //   - matchOne(b/x/y/z/c, b/**/c)
      //     - b matches b
      //     - doublestar
      //       - matchOne(x/y/z/c, c) -> no
      //       - matchOne(y/z/c, c) -> no
      //       - matchOne(z/c, c) -> no
      //       - matchOne(c, c) yes, hit
      var fr = fi
        , pr = pi + 1
      if (pr === pl) {
        if (options.debug)
          console.error('** at the end')
        // a ** at the end will just swallow the rest.
        // We have found a match.
        // however, it will not swallow /.x, unless
        // options.dot is set.
        // . and .. are *never* matched by **, for explosively
        // exponential reasons.
        for ( ; fi < fl; fi ++) {
          if (splitPath[fi] === "." || splitPath[fi] === ".." ||
              (!options.dot && splitPath[fi].charAt(0) === ".")) return false
        }
        return true
      }

      // ok, let's see if we can swallow whatever we can.
      WHILE: while (fr < fl) {
        var swallowee = splitPath[fr]

        if (options.debug) {
          console.error('\nglobstar while',
                        splitPath, fr, pattern, pr, swallowee)
        }

        // XXX remove this slice.  Just pass the start index.
        if (this.matchOne(splitPath.slice(fr), pattern.slice(pr), partial)) {
          if (options.debug)
            console.error('globstar found match!', fr, fl, swallowee)
          // found a match.
          return true
        } else {
          // can't swallow "." or ".." ever.
          // can only swallow ".foo" when explicitly asked.
          if (swallowee === "." || swallowee === ".." ||
              (!options.dot && swallowee.charAt(0) === ".")) {
            if (options.debug)
              console.error("dot detected!", splitPath, fr, pattern, pr)
            break WHILE
          }

          // ** swallows a segment, and continue.
          if (options.debug)
            console.error('globstar swallow a segment, and continue')
          fr ++
        }
      }
      // no match was found.
      // However, in partial mode, we can't say this is necessarily over.
      // If there's more *pattern* left, then 
      if (partial) {
        // ran out of file
        // console.error("\n>>> no match, partial?", file, fr, pattern, pr)
        if (fr === fl) return true
      }
      return false
    }

    // something other than **
    // non-magic patterns just have to match exactly
    // patterns with magic have been turned into regexps.
    var hit
    if (typeof p === "string") {
      if (options.nocase) {
        hit = f.toLowerCase() === p.toLowerCase()
      } else {
        hit = f === p
      }
      if (options.debug) {
        console.error("string match", p, f, hit)
      }
    } else {
      hit = f.match(p)
      if (options.debug) {
        console.error("pattern match", p, f, hit)
      }
    }

    if (!hit) return false
  }

  // Note: ending in / means that we'll get a final ""
  // at the end of the pattern.  This can only match a
  // corresponding "" at the end of the file.
  // If the file ends in /, then it can only match a
  // a pattern that ends in /, unless the pattern just
  // doesn't have any more for it. But, a/b/ should *not*
  // match "a/b/*", even though "" matches against the
  // [^/]*? pattern, except in partial mode, where it might
  // simply not be reached yet.
  // However, a/b/ should still satisfy a/*

  // now either we fell off the end of the pattern, or we're done.
  if (fi === fl && pi === pl) {
    // ran out of pattern and filename at the same time.
    // an exact hit!
    return true
  } else if (fi === fl) {
    // ran out of file, but still had pattern left.
    // this is ok if we're doing the match as part of
    // a glob fs traversal.
    return partial
  } else if (pi === pl) {
    // ran out of pattern, still have file left.
    // this is only acceptable if we're on the very last
    // empty segment of a file with a trailing slash.
    // a/* should match a/b/
    var emptyFileEnd = (fi === fl - 1) && (splitPath[fi] === "")
    return emptyFileEnd
  }

  // should be unreachable.
  throw new Error("wtf?")
}


// replace stuff like \* with *
function globUnescape (s) {
  return s.replace(/\\(.)/g, "$1")
}


function regExpEscape (s) {
  return s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&")
}
var mergesort = module.exports = function(array) {
    var len = array.length;

    if (len < 2) { 
      return array;
    }
    var pivot = Math.ceil(len/2);
    return merge(mergesort(array.slice(0,pivot)), mergesort(array.slice(pivot)));
};

function merge (left, right) {
    var result = [];
    
    // lowercasing left[0] & right[0] takes a lot of time...
    while((left.length > 0) && (right.length > 0)) {
      if ( left[0].toLowerCase() > right[0].toLowerCase()) {
        result.push(right.shift());
      }
      else {
        result.push(left.shift());
      }
    }

    result = result.concat(left, right);
    return result;
};
// filched mostly from https://github.com/andreyvit/pathspec.js
// given the ignore rules, creates an array of regexps to test files against

var MMB = minimatch.Minimatch;

function Ignorer(exclusions) {
  var r = 0, length = exclusions.length;
  this.ignores = [];
  var mmopt = { matchBase: true, dot: true, flipNegate: true };

  while (r < length) {
    exclusions[r] = exclusions[r].trim();
    if (exclusions[r].length === 0 || exclusions[r][0] === '#') {
      r++; continue;
    }

    this.ignores.push(new MMB(exclusions[r++], mmopt));
  }

  this.ignoresLength = this.ignores.length;
}

Ignorer.prototype.isFileIgnored = function(name, filepath, splitPath, showHidden) {
  if (!showHidden && (/^\.\w/.test(name))) {
    return true;
  }

  //console.log("fil " + name + " " + filepath);
  
  var r = 0;
  while (r < this.ignoresLength) {
    if (this.ignores[r++].match(name, filepath, splitPath))
      return true;
  }

  return false;
}

Ignorer.prototype.isDirIgnored = function(name, filepath, splitPath, showHidden) {
  if (!showHidden && (/\/\.\w/.test(name))) {
    return true;
  }

  //console.log("dir " + name + " " + filepath);
  
  var r = 0;
  while (r < this.ignoresLength) {
    if (this.ignores[r++].match(name, filepath, splitPath))
      return true;
  }
  return false;
}

Ignorer.makeWildcardRegExp = function(str, fullConversion) {
  if (!str)
    return "";

  // remove all whitespace
  str = str.replace(/\s/g, "");
  str = escapeRegExp(str);

  // convert wildcard norms to regex ones     
  str = str.replace(/\\\*/g, ".*");
  str = str.replace(/\\\?/g, ".");

  if (fullConversion) {
    // we wants pipe seperation, not commas
    // (this is a regexp list with ORs)
    str = str.replace(/,/g, "|");

    str = new RegExp("(?:" + str + ")");

    return str;
  }

  return str;
};

var escapeRegExp = Ignorer.escapeRegExp = function(str) {
  return str.replace(/([\/'*+?|()\[\]{}.\^$])/g, '\\$1');
}

module.exports = Ignorer;
// from https://gist.github.com/982499/e3c124da72796694a3bc08ed6e22d51b447d2575#file_options.js
/** Command-line options parser (http://valeriu.palos.ro/1026/).
    Copyright 2011 Valeriu Paloş (valeriu@palos.ro). All rights reserved.
    Released as Public Domain.

    Expects the "schema" array with options definitions and produces the
    "options" object and the "arguments" array, which will contain all
    non-option arguments encountered (including the script name and such).

    Syntax:
        [«short», «long», «attributes», «brief», «callback»]

    Attributes:
        ! - option is mandatory;
        : - option expects a parameter;
        + - option may be specified multiple times (repeatable).

    Notes:
        - Parser is case-sensitive.
        - The '-h|--help' option is provided implicitly.
        - Parsed options are placed as fields in the "options" object.
        - Non-option arguments are placed in the "arguments" array.
        - Options and their parameters must be separated by space.
        - Either one of «short» or «long» must always be provided.
        - The «callback» function is optional.
        - Cumulated short options are supported (i.e. '-tv').
        - If an error occurs, the process is halted and the help is shown.
        - Repeatable options will be cumulated into arrays.
        - The parser does *not* test for duplicate option definitions.
    */

var parser = {};
module.exports = parser;
// Option definitions.
var schema = [
    ['l', 'list',             '', '            list files encountered'],
    ['H', 'hidden',           '', '            search hidden files and directories (default off)'],
    ['c', 'color',            '',   '            adds color to results  (default off)'],
    ['a', 'pathToNakignore',  ':',  '    path to an additional nakignore file'],
    ['q', 'literal',          '', '            do not parse PATTERN as a regular expression; match it literally'],
    ['w', 'wordRegexp',       '',   '            only match whole words'],
    ['i', 'ignoreCase',       '',  '            match case insensitively'],
    ['G', 'fileSearch',       ':',  '    comma-separated list of wildcard files to only search on'],
    ['d', 'ignore',           ':',   '            comma-separated list of wildcard files to additionally ignore'],
    ['U', 'addVCSIgnores', '',   '            include VCS ignore files (.gitignore); still uses .nakignore'],
    ['',  'ackmate',           '',   '            output results in a format parseable by AckMate']
],

parseArgs = parser.parseArgs = function(passedArgs) {
    // Parse options; passedArgs are for VFS
    if (process.argv.length == 2 && !passedArgs) {
        help();
    }
    else if (passedArgs !== undefined) {
        process.argv = passedArgs;
    }

    var type;
    var tokens = [];
    var options = {};
    options.args = [];
    for (var i = 0, item = process.argv[0], argsLength = process.argv.length; i < argsLength; i++, item = process.argv[i]) {
        if (item.charAt(0) == '-') {
            if (item.charAt(1) == '-') {
                tokens.push('--', item.slice(2));
            } else {
                tokens = tokens.concat(item.split('').join('-').split('').slice(1));
            }
        } else {
            tokens.push(item);
        }
    }
    while ((type = tokens.shift())) {
        if (type == '-' || type == '--') {
            var name = tokens.shift();
            if (name == 'help' || name == 'h') {
                help();
            }
            var option = null;
            for (i = 0, item = schema[0]; i < schema.length; i++, item = schema[i]) {
                if (item[type.length - 1] == name) {
                    option = item;
                    break;
                }
            }

            var value = true;
            if ((option[2].indexOf(':') != -1) && !(value = tokens.shift())) {
                console.error("Option '" + type + name + "' expects a parameter!");
                help();
            }
            var index = option[1] || option[0];
            if (option[2].indexOf('+') != -1) {
                options[index] = options[index] instanceof Array ? options[index] : [];
                options[index].push(value);
            } else {
                options[index] = value;
            }
            if (typeof(option[4]) == 'function') {
                option[4](value);
            }
            option[2] = option[2].replace('!', '');
        } else {
            options.args.push(type);
            continue;
        }
    }

    // gets rid of the starting "node" and script name
    if (passedArgs === undefined) options.args.splice(0, 2);
    
    return options;
}

function help() {
    console.error("Usage: options ['PATTERN'] ['REPLACEMENT'] 'PATH' \n");
    console.error("Options:");
    for (var i = 0, item = schema[0]; i < schema.length; i++, item = schema[i]) {
        var names = (item[0] ? '-' + item[0] + (item[1] ? '|' : ''): '   ') +
                    (item[1] ? '--' + item[1] : '');
        var syntax = names + (item[2].indexOf(':') != -1 ? ' «value»' : '');
        syntax += syntax.length < 20 ? new Array(20 - syntax.length).join(' ') : '';
        console.error("\t" + (item[2].indexOf('!') != -1 ? '*' : ' ')
                         + (item[2].indexOf('+') != -1 ? '+' : ' ')
                         + syntax + "\t" + item[3]);
    }
    process.exit(0);
}
var fs = require("fs"),
    mergesort = mergesort,
    isBinaryFile = isbinaryfile;

function Finalizer(options, allPaths, allStats, printCb, done) {
  var dirKeys = mergesort(Object.keys(allPaths)), parent = "";
  var d, dLength;
  
  if (options.list) {
    var results = "";
    for (d = 0, dLength = dirKeys.length; d < dLength; d++) {
      parent = allPaths[dirKeys[d]];
      results += mergesort(parent).join("\n") + "\n";
    }

    printCb(results);
  }
  else {
    var contents, allFiles = [];

    for (d = 0, dLength = dirKeys.length; d < dLength; d++) {
      parent = allPaths[dirKeys[d]];
      allFiles = mergesort(parent);

      for (var m = 0, allFilesLength = allFiles.length; m < allFilesLength; m++) {
        var path = allFiles[m],
            fd = fs.openSync(path, 'r'),
            binaryBuffer = new Buffer(512);
            fs.readSync(fd, binaryBuffer, 0, 512, 0);
            fs.closeSync(fd);

        if (!isBinaryFile(binaryBuffer, allStats[path].size)) {
          contents = fs.readFileSync(path, "utf8");

          if (options.queryClean.test(contents)) {
            var strContents = contents.toString(),
                contentsSplit = strContents.split("\n"),
                  lines = "",
                  totalMatches = strContents.match(options.query).length, 
                  matchCount = totalMatches;

              if (options.replacement) {
                var replacedContents = strContents.replace(options.query, options.replacement);
                fs.writeFile(path, replacedContents, "utf8");
              }

              for (var i = 0, strLength = contentsSplit.length; matchCount && i < strLength; i++) {
                var matchLine = contentsSplit[i];
                if (options.queryClean.test(matchLine)) {
                  if (options.replacement)
                    matchLine = matchLine.replace(options.query, options.replacement);

                  if (!options.ackmate) {
                    lines += "\t" + (i+1) + ": " + matchLine + "\n"; 
                  }
                  else { // slower due to exec()
                    var result = options.queryClean.exec(matchLine);
                    lines += (i+1) + ";" + result.index + " " + result[0].length + ": " + matchLine + "\n"; 
                  }

                  matchCount--;        
                }
              }
              
              printCb(options.ackmate ? ":" + path : path + ":", lines, totalMatches);
            }
        }
      }
    }
    done();
  }
}

module.exports = Finalizer;
// gutted from walkdir: https://github.com/soldair/node-walkdir
// speed up a bunch.

var walker = {};
var finalizer, readdir, statter;
module.exports = walker;

var fs = require("fs"),
    path = require("path"),
    Ignorer = Ignorer,
    ignorer = null,
    allPaths = {},
    allStats = {},
    ended = 0,
    jobs = 0, 
    DIR_SEP = "/",

    // makes sure we're asynching right
    job = function(value) {
      jobs += value;

      if(value < 1 && !tick) {
        tick = 1;
        process.nextTick(function(){
          tick = 0;
          if(jobs <= 0 && !ended) {
            ended = 1;
            finalizer();
          }
        });
      }
    }, tick = 0;

walker.walkdir = function(fpath, options, printCb, done) {
  // if there are ignore rules, properly set them up
  ignorer = new Ignorer(options.exclusions, options.exclusionsLength);
  options.hidden = options.hidden || false;

  // called at the end of the walk
  finalizer = function() {
    Finalizer(options, allPaths, allStats, printCb, done);
  }

  statter = function (startingPath, parent, filepath) {
    job(1);
    var statAction = function fn(stat) {
      job(-1);
      if (stat.isFile()) { // i.e. not a symlink or other madness

        if (!options.list)
          allStats[filepath] = stat;
        if (allPaths[parent] === undefined)
          allPaths[parent] = [];

        allPaths[parent].push(filepath);
      }
      else if (stat.isDirectory()) 
        readdir(startingPath, filepath);
    };
    
    // lstat is SLOW, but what other way to determine if something is a directory or file ?
    // also, sync is about 200ms faster than async...
    statAction(fs.lstatSync(filepath));
  },

  readdir = function(startingPath, filepath) {

    var readdirAction = function(files) {
      job(-1);
      if (!files) { return;}

      var fileCount = files.length, i = 0, prefix = filepath + DIR_SEP, fpSplit = filepath.split(DIR_SEP);

      while (i < fileCount) {
        var file = files[i++], filename = prefix + file, prefixSplit = fpSplit;
        prefixSplit.push(file);
        if ((options.filesInclude.test(filename) || options.filesInclude.test(file)) && !ignorer.isFileIgnored(file, filename, prefixSplit, options.hidden)) {
          statter(file, filepath, filename);
        }
      }
    };

    if (!ignorer.isDirIgnored(path.basename(filepath), filepath, filepath.split(DIR_SEP), options.hidden)) {
      job(1);
      // async doesn't matter, we sort results at end anyway
      fs.readdir(filepath, function(err, files) {
        readdirAction(files);
      }); 
    }
  };

  // This is the main entry point
  readdir(fpath, fpath);
}


var options = parser.parseArgs(passedArgs),
    fs = require('fs'),
    path = require('path'),
    walkdir = walker.walkdir,
    ignorer = Ignorer;

// arguments
var fpath = path.resolve(options.args.pop()),
    replacement = null,
    query = null,
    fileColor = "", textColor = "", matchColor = "";

if (options.args.length == 1)
  query = options.args.pop();
else if (options.args.length == 2) {
  replacement = options.args.pop();
  query = options.args.pop();
}

if (options.color) {
  fileColor = '\n\033[36m%s\033[0m';
  textColor = '\033[37;43m\1\033[0;90m';
  matchColor = '\033[90m%s';
}

options.filesInclude = options.fileSearch ? ignorer.makeWildcardRegExp(options.fileSearch, true) : { test: function(){ return true }};

setExclusions(fpath);

// set the query up, and present a final summary; also, pump out results as they come.
// "streaming" output like this is slower (because console.log blocks)
// but serves a purpose when finding text
if (typeof callback != "undefined") {
  var Stream = require('stream').Stream;
  var stream = new Stream();
  stream.readable = true;
    
  callback(null, {stream: stream});
    
  if (query) {
    makeQuery(query, replacement);
    var matches = 0, filecount = 0;
    var output = "";
  
    walkdir(fpath, options, function(file, lines, _matches) {  
      stream.emit("data", file + "\n" + lines);
      matches += _matches;
      filecount++;
    }, function() {
      if (!options.ackmate)
        stream.emit("data", "Found " + matches + (matches == 1 ? " match" : " matches")  
          + " in " + filecount + (filecount == 1 ? " file " : " files ")); 
      
      stream.emit("end", {count : matches, filecount: filecount});
    });
  }
  // if we're listing, callback at the very end
  else if (options.list) {
    walkdir(fpath, options, function(lines) {
        stream.emit("data", lines);
        stream.emit("end");
    });
  }
}
else if (query) {
  makeQuery(query, replacement);
  var matches = 0, filecount = 0;

  walkdir(fpath, options, function(file, lines, _matches) {  
    if (!options.color) {
      console.log(file);
      console.log(lines);
    }
    else {
      console.log(fileColor, file + ":");
      lines = lines.replace(options.query, textColor);
      console.log(matchColor, lines);
    }

    matches += _matches;
    filecount++;
  }, function() {
    if (!options.ackmate)
      console.log("Found " + matches + (matches == 1 ? " match" : " matches")  
        + " in " + filecount + (filecount == 1 ? " file " : " files ")); 
  });
}
// if we're listing, callback at the very end
else if (options.list) {
  walkdir(fpath, options, function(lines) {
    console.log(lines);
  });
}

function setExclusions(fpath) {
  var referencedExclusions = "",
      nakExclusions = "",
      gitExclusions = "";

  // if these ignore files don't exist, don't worry about them
  if (options.pathToNakignore) {
  try {
      referencedExclusions = fs.readFileSync(options.pathToNakignore, "utf-8");
    } catch (e) { };
  }

  try {
    nakExclusions = fs.readFileSync(fpath + path.sep + ".nakignore", "utf8");
  } catch (e) { };

  if (options.addVCSIgnores) {
    try {
      gitExclusions = fs.readFileSync(fpath + path.sep + ".gitignore", "utf8");
    } catch (e) { };
  }
  
  var combinedExclusions = referencedExclusions + "\n" + 
                           nakExclusions + "\n" + 
                           gitExclusions + "\n" + 
                           (options.ignore || "");

  if (combinedExclusions.length) {
    options.exclusions = combinedExclusions.split(/\r?\n/);
  }
};

function makeQuery(query, replacement) {
  var flags = "g";
  if (options.literal) 
    query = ignorer.escapeRegExp(query);
  if (options.ignoreCase)
    flags += "i";

  if (options.wordRegexp)
    query = "\\b(?:" + query + ")\\b";

  options.query = new RegExp(query, flags);

  if (replacement) {
    options.replacement = replacement;
  }

  options.queryClean = new RegExp(query, flags.substr(1));
}
	}
  	}); 
};